## 网络设备初始化

### 目录


#### 中断共享

- 中断共享的原因：  
  > IRQ线资源有限；  
  > 增加系统能容纳设备数目的简单方式就是: 允许几台设备共享同一个IRQ;  
  > 正常来讲，每个设备会针对该IRQ将其自己的处理例程注册给内核,再由内核启用那些注册同一共享IRQ的设备的所有处理例程；  

- 中断共享处理：  
  > 每一个设备注册使用一条IRQ时，必须说明其是否支持中共享；  
  > 如果有一个设备已经注册一条IRQ，此设备无法共享IRQ，那么当另一设备注册该IRQ时就会被拒绝；  

#### IRQ处理例程映射的组织
- IRQ处理例程的映射存储在一个表向量中，每一个IRQ对应一个处理例程列表。只有当多台设共享同一个IRQ时，一个列表中才会有一个以上的元素;  
- 向量表的大小取决于具体的体系结构，可以从**15变化到200以上**,由体系结构依赖符号`NR_IRQS`指定;  
- 中断映射用`irqaction`数据结构定义,其结构如下；
  - `void (*handler) (int irq, void *dev_id, struct pt_regls *regs)`
    > 由设备驱动程序所提供的函数，用以处理**中断的通知信息**；  
    > - `int irq`：**产生此通知信息的IRQ编号**。一般，NIC设备驱动程序不用此参数就能完成工作，只要有设备ID就可以了；  
    > - `void *dev_id`： **设备标识符**。同一驱动程序可能同时要负责不同的设备，所以需要设备ID来处理通知信息；  
    > - struct pt_regs *regs：中断事件打断当前进程时，用于存储处理器的寄存器内容的结构；  

  - `unsigned long flags`
    > 一组标识。可能的取值SA_XXX定义在`include/asm-XXX/signal.h`中；  
    > 可能的取值有：`SA_SHIRQ`（可处理共享的IRQ）、`SA_SAMPLE_RANDOM`（随机事件来源）等；  

  - `void *dev_id`
    > 与此设备关联的`net_device`数据结构的指针。由于有各种类型的设备，因此声明为通用类型;

  - `struct irqacton *next`
    > 所有共享同一个IRQ编号的设备会用此指针链接成一个列表；
  
  - `const char *name`
    > 设备名称。可通过`/proc/interrupts`的内容来读取设备名称；

- 中断的注册与删除由`request_irq()` 和 `free_irq()` 函数完成；
- 中断全局向量irq_desc在`kernel/irq/handler.c`中,可以在每个体系结构文件`arch/XXX/kernel/irq.c`中被重写；
- 处理中断并将其传给驱动程序的内核函数称之为`handle_IRQ_evnet`;

#### 初始化选项
内核內建的组件以及作为模块加载的组件都能通过**输入参数**，使用户调整组件所实现的功能，重写其默认参数，或者在系统引导前后有不同的值。  
输入参数主要分为以下两类：  

- 模块选项(`module_param`系列的宏)
  > 当**加载模块时**可以提供这些定义的选项;  
  > 引入**sys文件系统**后，可以通过这些文件**在运行期间**配置这些选项；  

- 引导期间内核选项(`_ _setup`系列的宏)
  > 在引导加载程序**引导期间**提供这些定义选项；  
  > 这些选项主要由那些可内建在内核模块以及不能编译成模块的内核组件使用；  

一个模块可以按照两种方式定义初始化选项：

- 当模块**內建在内核**时，第一种方式有效；  
- 当模块**独立加载**时，另一种方式有效；  

#### 模块选项
内核模块采用module_param宏的方式定义其参数。如：  
```c
module_param(multicast_filter_limit, int, 0444);
module_param(max_interrupt_work, int, 0444);
```
*参数说明*：  

- 第一个参数是用户使用的**参数名称**；  
- 第二个参数是**参数类型**（如整型、字符串等）;  
- 第三个参数是参数作为文件输出到/sys时，分派给该**文件的权限**；  

每个模块在`/sys/modules`中都会被分派一个目录，目录中的每个文件就是该模块输出的每个参数。  

#### 设备处理层初始化：`net_dev_init`
网络设备初始化包括：**流量控制** 和 **各CPU**入口队列。这些工作在
引导期间由`net/core/dev.c`中的`net_dev_init`完成。  
`net_dev_init`的主要工作有：  

- 由两个网络软件中断所使用的对应的各CPU的数据结构的初始化；  
- 当内核被编译为支持`/proc`文件系统时，通过`dev_proc_init`和
  `dev_mcast_init`添加到`/proc`；
- `netdev_sysfs_init`向`sysfs`注册为`net`类,这样就会在`/sys/class/net`目录中创建每个已注册网络设备的子目录；
- `net_random_init`初始化一个对应各个CPU的种子向量，用于`net_random`函数产生随机数；
- `dst_init`做用于协议无关的目的缓存
- 初始化协议处理例程向量`ptype_base`，用于分离入口；流量的多路合并传输；
- 如果定义`OFFLINE_SAMPLE`，`net_dev_init`会建立一个定时器，用以定期执行设备队列长度统计函数；
- 把一个回调函数处理例程注册到发出相关CPU热插拔事件的通信信息的通知链；

随机数的产生是通过一个辅助函数，内核借此函数令其自身随某些活动随机化。很多网络子系统都有使用随机产生的值。  

#### 用户空间辅助程序
有些情况下，内核会调用用户空间的应用程序来处理事件，如：  

- `/sbin/modprobe`
  > 当内核需要加载模块时就会调用该程序；

- `/sbin/hotplug`
  > 当内核侦测到一个新设备已经插入或拔出系统时就会被调用；  
  > 其主要工作是根据设备标识符加载正确的驱动程序或模块；  
  > 设备标志符是通过所插入的总线以及总线规范所定义的相关联的ID；  

内核提供了一个名为`call_usermodehelper`的函数，来执行这类用户空间的辅助程序。同时，该程序允许调用者通过`arg[]`传递一些自变量，并通过`env[]`传递一些环境变量给应用程序。  

#### kmod
`kmod`是内核模块加载程序，允许内核组件请求加载一个模块。`request_module`就是一个模块加载程序（内核不知提供这一个模块加载程序）。此函数用`arg[1]`作为要加载的模块名。  

#### 热拔插
Linux内核引入热拔插是为了实现**即插即用（PnP, Plug and Play）**。这项功能让内核去侦测可热拔插设备的插入与删除。  
热拔插可在引导期间用于非热拔插设备。  
在`/lib/modules/kernel_version/`目录下的`modules.pcimap`和`modules
.usbmap`分别包含了内核所支持设备的PCI ID和USB ID。同时还包含了相关
联的内核模块的引用。当用户空间辅助程序接收到一个可热插拔设备正在插入或删除时，就会使用这些文件找到正确的设备驱动程序。  

#### /sbin/hotplug
Hotplug套件可在`/etc/hotplug`和`/etc/hotplug.d`中进行配置。  
内核会调用`kobject_hotplug`函数来响应一个设备的插入和删除以及其事件。`kobject_hotplug`会把`arg[0]`初值设为`/sbin/hotplug`，把`arg[1]`设为要使用的代码处理程序。  
当一块NIC添加到系统或从系统删除时，`kobject_hotplug`会把`arg[1]`初值设为`net`,使得`/sbin/hotplug`去执行`net.agent`代理程序。  
`net.agent`可应用与新设备相关联的任何配置，因此内核必须提供设备标识
符。其中，设备标识符可通过`INTERFACE`环境变量传入。  
为了能够配置设备，`net.agent`必须先由内核创建并注册。该任务由先关联的设备程序驱动。如，添加一块`PCMCIA Ethernet`卡会调用好几次`/sbin/hotplug`,包括  

- 执行`/sbin/modprobe`加载正确的模块设备驱动程序；  
- 配置新设备，由`net.agent`代理程序完成；  

#### 虚拟设备
虚拟设备是建立在一个或多个真实设备之上的抽象。虚拟设备与真实设备之间的关联可以是多对多的。  
Linux允许定义多种不同的虚拟设备，如：  

- 绑定(bonding)
  > 利用这个功能，虚拟设备可以绑定一组物理设备，使用如同单一设备；

- `802.1Q`
  > 这是VLAN标准，扩充`802.3/Ethernet`帧头；

- 桥接
  > 桥接接口就是网桥的虚拟代表；

- 别名接口
  > 主要允许单一真实的Ethernet接口横跨几个虚拟接口(`eth0:0, eth0:1`)，每个接口都有自己对应的IP地址；

- 隧道接口(*tunnel interface*)
  > IP-over-IP(IPIP)隧道以及GRE(Generalized Routing Encapsulation, 通用路由封装)协议的实现基础就是虚拟设备的建立；

#### 与内核网络协议栈之间的交互
虚拟设备和真实设备与内核的交互方式略有不同，主要区别于一下几点：  

- 初始化 
  > 大多数虚拟设备如同真实设备一样，都会被分派一个`net_device`数据结构。但是并非所有虚拟设备都会被分派一个`net_device`结构，别名设备就是这种类型；

- 配置 
  > 虚拟设备常用特殊用户空间的工具来配置，可能无法使用如`ifconfig`这标准工具来配置；

- 外部接口
  > 每个虚拟设备通常都会输出一个文件或一个内含一些文件的目录到`/proc`文件系统内；

- 传输 
  > 当虚拟设备与真实设备之间有多重关系时，需要配置流量控制；

- 接收 
  > 虚拟设备流量是间接接收获取的，来自于执行这些任务的真实物理设备；

- 外部通知信息 

#### 通过/proc文件系统调整
/proc中的一些文件会输出内部数据结构和配置参数的值，有助于记录设备驱动程序分配了哪些资源。  
在`/proc/net`中，可以找到由`net_dev_init`通过`dev_proc_init`和
`dev_mcast_init`所创建的文件：  

- `dev`
  > 对每个已注册的网络设备而言，会显示一些有关接收和传输的统计数据，如以接收和已传输的字节数、封包数目以及错误等；

- `dev_mcast`
  > 会显示一些由IP多播所使用的参数；

- `wireless`
  > 会显示每个无线设备的统计数据；

- `softnet_stat`
  > 输出有关由网络代码所使用的软件中断的统计数据；

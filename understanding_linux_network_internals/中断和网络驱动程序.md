### 中断和网络驱动程序

### 目录


#### 决策和流量方向
数据包在网络协议栈中所走的路径根据数据包是传输、接收还是转发不同而不同：  

![] [package_road]

但虚拟设备可能有所不同，如回环设备不会使用硬件设备的协议栈，而有些设备可以避免硬件的某些硬件限制如MTU等，因而可以提供性能。  

![] [input_road]

#### 接收到帧时通知驱动程序
设备与内核有两种主要技术来进行数据交换：  

- 轮询  
  > 不断读取设备的一个内存寄存器或者当一个定时器到期后检查那个内存寄存器，从而获取设备状态，是否有需要处理的网络数据包。  
  > 这种方式看起来会比中断浪费更多的系统资源，但当中断过于频繁，系统需要不断切换进行上下文时，反而是一种非常好的方式。  

- 中断  
  > 当网络数据包到达时，设备会产生硬件中断调用设备驱动程序注册的中断处理程序，让内核来处理数据包。在**低流量**负载下是最佳的选择，但在**高流量**负载下会让CPU为处理中断事件不断却换环境而浪费时间。  
  > 接收数据帧分为两部分工作：  

  > - 驱动程序将数据包复制到内核可访问的输入队列；  
  > - 内核予以处理，将帧传给相关协议专用的处理函数；  

  > 第一部分在中断环境中执行，可以抢占第二部分的执行。接收输入帧并将其拷贝到队列的代码比实际处理帧的代码具有更高的优先级。  
  > 因此，当高流量负载下，中断代码会持续抢占正在处理的代码。使得旧数据得不到包处理，输入队列就会溢出。这种情况就是`receive-livelock`现象，虽然没有死锁，但是系统也会崩溃。

#### 下半部函数存在的原因
中断事件产生的一般流程：  

- 设备产生一个中断事件，硬件通知内核；
- 若内核没有正在处理其他中断，或中断因其他原因而关闭，则可以处理该中断；
- 内核首先关闭本地CPU的中断功能，然后执行中断事件中的中断服务函数；
- 内核会在处理该中断后，重启本地CPU的中断功能；

中断处理函数是非抢占的，而且是非可再进入的。这种设备可以降低竞争的可能性，但对CPU能做的事会有所限制。因此，中断处理函数所做的工作应该尽快完成。  


中断处理函数分成上半部和下半部。该模型下，中断事件产生的一般流程：  

- 设备发出信号给CPU，通知有中断事件。
- CPU会执行相关的上半部，关闭后续的中断事件通知信息，直到此处理函数完成为止。
- 一般而言，上半部会执行下列工作：  
  - 把内核稍后处理该中断事件的所有信息保存在RAM某处；
  - 在某处标记一个标识，以确保内核会知道该中断事件，而且会使用处理函数所保存的数据以完成事件的处理。
  - 终止前，重新启用本地CPU的中断事件通知信息功能；


[package_road]: http://blog.chinaunix.net/attachment/201305/28/14518381_136974795070P5.png "流量方向"
[input_road]: http://blog.chinaunix.net/attachment/201305/28/14518381_1369747958Rt6G.png "入口路径(帧接收)"


